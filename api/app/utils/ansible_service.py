"""Utility functions for interacting with Ansible to gather platform information."""

import os
import json
import asyncio
import time

import ansible_runner
from fastapi import HTTPException

REPORTS_DIR = "/code/ansible/platform_reports"
PLAYBOOK_DIR = "/code/ansible"


def parse_platform_report(hostname: str) -> dict:
    """
    Reads and parses the JSON file generated by Ansible.
    Returns a dictionary matching the Machines model.
    :param hostname: Hostname of the machine
    :return: Dictionary with platform information
    """
    report_path = os.path.join(REPORTS_DIR, f"{hostname}-platform-info.json")

    if not os.path.exists(report_path):
        raise FileNotFoundError(f"Report not found for {hostname} at {report_path}")

    time.sleep(1)
    try:
        with open(report_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        root_key = list(data.keys())[0]
        info = data[root_key]

        cpu_info = info.get("cpu", {})
        cpu_str = (
            f"{cpu_info.get('name', 'Unknown')} "
            f"({cpu_info.get('cores', '?')} cores)"
        )

        ram_info = info.get("ram_memory", {})
        ram_str = f"{ram_info.get('real_gb', '?')} GB"

        drives = info.get("drives", [])
        disk_list = []
        for d in drives:
            size_gb = d.get("size_gb", "?")
            mount = d.get("mount", "?")
            disk_list.append(f"{mount} ({size_gb}GB)")
        disk_str = ", ".join(disk_list) if disk_list else "Unknown"

        dist = info.get("distribution", {})
        os_str = f"{dist.get('name', 'Linux')} {dist.get('version', '')}"

        net = info.get("network", {})
        mac_address = net.get("mac")
        ip_address = net.get("ip")

        meta = info.get("metadata", {})
        has_node_exporter = meta.get("has_agent", False)

        return {
            "name": root_key,
            "os": os_str,
            "cpu": cpu_str,
            "ram": ram_str,
            "disk": disk_str,
            "mac_address": mac_address,
            "ip_address": ip_address,
            "agent_prometheus": has_node_exporter,
        }

    except Exception as e:
        raise ValueError(f"Error parsing report for {hostname}: {str(e)}") from e


async def run_playbook_task(playbook_path: str, host: str | list, extra_vars: dict):
    """
    Helper function to run an Ansible playbook on a single host dynamically.
    :param playbook_path: Path to the Ansible playbook
    :param host: Host IP or hostname
    :param extra_vars: Extra variables for the playbook
    :return: Result of the playbook execution
    """

    if isinstance(host, str):
        hosts_list = [h.strip() for h in host.split(",") if h.strip()]
    else:
        hosts_list = host

    host_dict = {"all": {"hosts": {h: {} for h in hosts_list}}}

    def _run():
        return ansible_runner.run(
            playbook=playbook_path,
            inventory=host_dict,
            extravars=extra_vars,
        )

    try:
        r = await asyncio.to_thread(_run)
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Failed to execute Ansible runner: {e}"
        )
    if r.rc != 0 or r.status != "successful":
        raise HTTPException(
            status_code=500,
            detail={
                "message": "Ansible playbook execution failed",
                "status": r.status,
                "rc": r.rc,
            },
        )
    return {"status": r.status, "rc": r.rc}